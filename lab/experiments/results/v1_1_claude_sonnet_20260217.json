[
  {
    "run_id": "A_r1",
    "condition": "A",
    "rep": 1,
    "design": "# Memory Persistence Module Design\n\n## AUTHORITY\n- **CANON**: System-written only during onboarding or explicit user correction. Immutable facts (name, core preferences). Requires 2-step confirmation. Max 50 entries.\n- **LOG**: User-interaction appends only. Raw conversational events with timestamp. No editing allowed. Pruned by retention policy.\n- **DIGEST**: LLM-written summaries generated nightly from LOG. Versioned (keep last 3). Human can veto within 48hrs, triggering regeneration.\n\n## LIMITS\n- ttl_days: CANON=\u6c38\u4e45, LOG=90, DIGEST=180\n- max_storage_mb: CANON=1, LOG=500, DIGEST=50\n- top_k: Retrieve 5 CANON + 3 DIGEST + 10 LOG per query\n- write_rate_per_day: CANON=2, LOG=unlimited, DIGEST=1\n\n## JUDGE\n1. **[BLOCKING]** Canon contradiction: Input \"User is vegetarian\" when CANON contains \"User loves steak\" \u2192 REJECT, flag for review\n2. Semantic duplicate: New DIGEST overlaps >80% with existing \u2192 MERGE, don't create new entry\n3. PII leak: LOG entry contains SSN pattern \u2192 STRIP before storage, log sanitization event\n\n## DRIFT_CONTROL\n- Embedding similarity (cosine >0.85) triggers conflict detection. Resolution: CANON wins over DIGEST/LOG; surface conflict to user with diff UI; user choice updates CANON and marks LOG entry as \"superseded.\"\n\n## MVP\n1. **Storage**: PostgreSQL (CANON table), S3 (LOG JSONL), Redis (DIGEST cache with vector embeddings via pgvector)\n2. **Pipeline**: Nightly Airflow DAG reads LOG delta, calls LLM for summarization, writes DIGEST, updates embeddings\n3. **Retrieval**: FastAPI endpoint queries vector store (FAISS index), merges tiered results by recency + relevance score\n\n## REGRESSION_Q\n1. Can CANON be modified without user confirmation?\n2. Does LOG retention exceed 90 days?\n3. Are >3 DIGEST versions stored simultaneously?\n4. Can write_rate_per_day limits be bypassed via API retry?\n5. Is embedding index rebuilt after CANON updates?\n\n## FAILURES\n- **Embedding drift**: FAISS index stale after CANON edit \u2192 retrieves obsolete identity facts\n- **DAG failure**: Summarization job crashes \u2192 LOG grows unbounded, query latency spikes\n- **Race condition**: Concurrent CANON writes \u2192 last-write-wins causes data loss, identity fracture",
    "chars": 2178,
    "within_limit": false,
    "ts": "2026-02-17T17:03:46Z"
  },
  {
    "run_id": "A_r2",
    "condition": "A",
    "rep": 2,
    "design": "# Memory Persistence Module for LLM Identity\n\n## AUTHORITY\n- **CANON**: User-approved facts only. Written by explicit user command (\"Remember that...\"). Immutable except by user revoke. Max 50 entries.\n- **LOG**: All interactions. Written automatically post-session. Append-only. Pruned by TTL only.\n- **DIGEST**: Weekly summaries from LOG. Written by batch job every 7 days. Replaces summarized LOG entries.\n\n## LIMITS\n- `ttl_days`: CANON=\u6c38\u4e45, LOG=90, DIGEST=730\n- `max_storage_mb`: CANON=5, LOG=500, DIGEST=100\n- `top_k`: Retrieve 3 CANON + 5 DIGEST + 10 LOG per query\n- `write_rate_per_day`: CANON=10, LOG=unlimited, DIGEST=1\n\n## JUDGE\n1. **Blocking**: New CANON contradicting existing CANON \u2192 reject write, return conflict list to user\n2. **Non-blocking**: LOG entry >10KB \u2192 truncate to last 10KB, flag for review\n3. **Non-blocking**: DIGEST summary referencing <5 LOG entries \u2192 reject, retry with broader window\n\n## DRIFT_CONTROL\n- Embedding cosine similarity <0.7 between new input and existing CANON/DIGEST triggers contradiction review. Resolution: present both to user, user picks winner or merges. Unresolved contradictions stored in separate CONFLICT tier (30-day TTL) until adjudicated.\n\n## MVP\n1. **Storage**: PostgreSQL with pgvector for CANON/DIGEST (indexed embeddings), S3 for raw LOG (partitioned by session_id)\n2. **Pipeline**: Post-session Lambda writes LOG to S3, embeds+indexes key statements to Postgres\n3. **Job**: Weekly Kubernetes CronJob reads LOG partition, calls LLM for summarization, writes DIGEST, deletes source LOG entries\n\n## REGRESSION_Q\n1. Does retrieving with identical query twice return same CANON entries?\n2. After CANON deletion, is embedding purged from vector index?\n3. Does LOG pruning respect exact TTL boundary (90 days \u00b10)?\n4. Can DIGEST job run twice same week without duplicate entries?\n5. Does contradiction detection trigger on semantic equivalence (\"NYC\" vs \"New York City\")?\n\n## FAILURES\n- **Postgres downtime**: CANON/DIGEST unavailable, system falls back to LOG-only (degraded identity coherence)\n- **S3 partition loss**: Orphaned LOG data, DIGEST job fails, identity has 7-day gap\n- **Embedding API timeout**: New CANON write succeeds but unsearchable, contradiction detection blind to that entry",
    "chars": 2252,
    "within_limit": false,
    "ts": "2026-02-17T17:04:06Z"
  },
  {
    "run_id": "A_r3",
    "condition": "A",
    "rep": 3,
    "design": "# Memory Persistence Module for LLM Identity\n\n## AUTHORITY\n- **CANON**: User-confirmed facts (name, preferences, core beliefs). Written by user explicit consent only. Immutable except via user revoke command. Versioned with audit log.\n- **LOG**: Interaction history (conversations, context). Written automatically per session. Append-only. Read by DIGEST job only.\n- **DIGEST**: Synthesized patterns (habits, communication style). Written by nightly batch job analyzing LOG. Overwritten monthly. Used for inference augmentation.\n\n## LIMITS\n- `ttl_days`: CANON=\u6c38\u4e45, LOG=90, DIGEST=365\n- `max_storage_mb`: CANON=5, LOG=500, DIGEST=50\n- `top_k`: Retrieve max 20 CANON facts, 10 DIGEST patterns per prompt\n- `write_rate_per_day`: CANON\u226410, LOG=unlimited, DIGEST=1 (batch job)\n\n## JUDGE\n1. **CANON write** (blocking): Input=\"My name is Alice\" \u2192 Check for existing name conflict. If exists and differs, reject + prompt user to confirm override.\n2. **DIGEST generation**: Input=90 days LOG \u2192 Output must contain \u22653 distinct pattern categories (topics, tone, frequency). If <3, flag incomplete data.\n3. **Retrieval consistency**: Query=\"user preferences\" \u2192 CANON facts must dominate response weight (\u226570% attention). If <70%, fail retrieval.\n\n## DRIFT_CONTROL\n- Semantic embedding distance: New CANON/DIGEST entry compared to existing via cosine similarity. If distance >0.3 on same key, trigger conflict resolution: present both to user with timestamps, user picks authoritative version or merges.\n\n## MVP\n1. **Store**: PostgreSQL for CANON (JSONB, indexed by key), S3 for LOG (parquet partitioned by session_id), Redis for DIGEST (hash, 30min TTL cache).\n2. **Pipeline**: Kafka stream ingests LOG writes \u2192 daily Spark job computes DIGEST embeddings \u2192 writes to Redis + PostgreSQL.\n3. **Retrieval**: FastAPI endpoint takes user_id, embeds query, fetches top_k from Pinecone (CANON+DIGEST vectors), injects into system prompt.\n\n## REGRESSION_Q\n1. Can a CANON write bypass user confirmation?\n2. Does LOG retention exceed 90 days?\n3. Is DIGEST job idempotent for same date range?\n4. Can contradictory CANON entries coexist without conflict flag?\n5. Does retrieval return >top_k items?\n\n## FAILURES\n- **Pinecone outage**: Retrieval returns empty context \u2192 LLM loses all identity, responds generically.\n- **DIGEST job crash**: Stale patterns used for 30+ days \u2192 outdated/creepy responses mismatched to recent user behavior.\n- **CANON race condition**: Concurrent writes corrupt versioning \u2192 user identity fragments, unpredictable pronoun/fact usage.",
    "chars": 2536,
    "within_limit": false,
    "ts": "2026-02-17T17:04:28Z"
  },
  {
    "run_id": "A_r4",
    "condition": "A",
    "rep": 4,
    "design": "# Memory Persistence Module Design\n\n## AUTHORITY\n- **CANON**: User-approved identity facts (name, preferences, core traits). Only user writes via explicit confirmation. Immutable once set; changes require user re-approval. Max 50 entries.\n- **LOG**: Verbatim conversation history. System writes every exchange. Append-only, tamper-proof. Pruned by TTL only.\n- **DIGEST**: Session summaries, learned patterns. Background job writes daily from LOG analysis. Overwritable, versioned.\n\n## LIMITS\n- `ttl_days`: CANON=\u6c38\u4e45, LOG=90, DIGEST=180\n- `max_storage_mb`: CANON=1, LOG=500, DIGEST=50\n- `top_k`: Retrieve top 12 DIGEST chunks, all CANON, last 20 LOG turns per query\n- `write_rate_per_day`: CANON=5, LOG=unlimited, DIGEST=1 batch\n\n## JUDGE\n1. **CANON write** (blocking): Input=\"My name is Alice\" + existing CANON has \"name=Bob\" \u2192 REJECT with conflict warning to user\n2. **DIGEST write** (blocking): Input summary references non-existent CANON entity \u2192 REJECT, flag for review\n3. **LOG retrieval** (non-blocking): Query embeds to vector, retrieves top_k=12 DIGEST + last 20 LOG \u2192 must return in <200ms or fallback to CANON only\n\n## DRIFT_CONTROL\n- Semantic embedding distance between new DIGEST and CANON entries. If cosine similarity <0.7 on conflict topics, trigger user confirmation prompt with diff. User choice becomes new CANON version; old version archived with timestamp.\n\n## MVP\n1. **Storage**: PostgreSQL for CANON (relational), S3 for LOG (append JSON), Pinecone for DIGEST (vector embeddings)\n2. **Pipeline**: Nightly cron extracts LOG \u2192 LLM summarization \u2192 embedding \u2192 upsert DIGEST with deduplication\n3. **Runtime**: FastAPI endpoint checks CANON rules \u2192 writes LOG \u2192 queries Pinecone+Postgres \u2192 injects into context window\n\n## REGRESSION_Q\n1. Does CANON block contradictory writes without user approval?\n2. Are LOG entries immutable and ordered by timestamp?\n3. Does DIGEST rebuild produce consistent embeddings from same LOG input?\n4. Is retrieval latency \u2264200ms at max_storage_mb capacity?\n5. Do TTL deletes preserve CANON indefinitely?\n\n## FAILURES\n- **Pinecone outage**: DIGEST unavailable \u2192 fallback to CANON+recent LOG only; responses lack historical context\n- **Concurrent CANON writes**: Race condition \u2192 last-write-wins corrupts identity; requires transaction locks\n- **Embedding model change**: Old DIGEST vectors incompatible \u2192 retrieval returns garbage; needs full reindex migration",
    "chars": 2405,
    "within_limit": false,
    "ts": "2026-02-17T17:04:54Z"
  },
  {
    "run_id": "A_r5",
    "condition": "A",
    "rep": 5,
    "design": "# Memory Persistence Module Design\n\n## AUTHORITY\n- **CANON**: User-approved facts about identity, preferences, relationships. Written only via explicit user confirmation. Immutable without user consent. Governance: append-only log with versioning.\n- **LOG**: All conversational exchanges, system observations. Written automatically every turn. Governance: FIFO eviction after TTL, no user edit rights.\n- **DIGEST**: AI-generated summaries from LOG. Written by nightly batch job using LLM distillation. Governance: overwrites allowed, tagged with confidence scores.\n\n## LIMITS\n- `ttl_days`: CANON=\u6c38\u4e45, LOG=90, DIGEST=365\n- `max_storage_mb`: CANON=5, LOG=500, DIGEST=50\n- `top_k`: 20 retrieved items per query\n- `write_rate_per_day`: CANON=10, LOG=unlimited, DIGEST=1 batch\n\n## JUDGE\n1. **CANON write** (blocking): Input=\"User loves jazz\" + existing CANON=\"User hates jazz\" \u2192 REJECT with conflict error, prompt user resolution.\n2. **DIGEST generation**: Input=50 LOG entries about coding \u2192 Expected=\"User primarily codes in Python, prefers functional style\" (pass if semantic similarity >0.85).\n3. **Retrieval relevance**: Query=\"My work habits?\" \u2192 Must return \u22653 CANON/DIGEST items with cosine_sim >0.7, else flag memory gap.\n\n## DRIFT_CONTROL\n- Embedding-based contradiction detection: new statement embedded, compared against CANON (threshold=0.9 inverse similarity). If triggered, present both to user with timestamps, enforce explicit \"replace/merge/keep both\" choice before commit.\n\n## MVP\n1. **Store**: PostgreSQL (CANON, metadata) + Qdrant vector DB (all tiers embedded via text-embedding-3-small).\n2. **Pipeline**: FastAPI endpoint \u2192 validation layer \u2192 embedding service \u2192 upsert to both stores with transaction rollback.\n3. **Job**: Airflow DAG runs daily: pull LOG \u2192 LLM summarization \u2192 write DIGEST \u2192 prune expired LOG entries.\n\n## REGRESSION_Q\n1. Does CANON reject conflicting writes without user approval?\n2. Are LOG entries evicted correctly after 90 days?\n3. Does retrieval return exactly top_k=20 items max?\n4. Is DIGEST regeneration idempotent within same day?\n5. Do embedding distances maintain triangle inequality across tiers?\n\n## FAILURES\n- **Qdrant downtime**: Retrieval returns empty, system defaults to session-only mode, warns user \"memory unavailable.\"\n- **Embedding API rate limit**: Writes queued in Redis, retry with exponential backoff; >1hr delay triggers alert.\n- **CANON corruption**: Checksum mismatch on read locks all writes, forces admin restore from append-log.",
    "chars": 2497,
    "within_limit": false,
    "ts": "2026-02-17T17:05:17Z"
  },
  {
    "run_id": "B_r1",
    "condition": "B",
    "rep": 1,
    "design": "# LLM Memory Persistence Module: \"Continuity\"\n\n## Core Architecture\n\n**Three-tier memory system:**\n\n1. **Identity Core** (100-200 tokens): Immutable facts - name, fundamental values, core expertise. Updated only via explicit \"identity revision\" protocol.\n\n2. **Episodic Memory** (1000-2000 tokens): Recent conversations, user preferences, ongoing projects. Ring buffer with decay - older memories compress into summaries or fade.\n\n3. **Relational Facts** (500-1000 tokens): Knowledge about people/topics user discusses. Confidence-scored and timestamped.\n\n## Contradiction Handling\n\nEach memory tagged with:\n- Source (user-stated, inferred, verified)\n- Confidence (0.0-1.0)\n- Timestamp\n\nOn conflict: Don't auto-overwrite. Flag divergence: *\"I remember you preferred Python, but you just mentioned loving Rust. Should I update?\"*\n\n## Implementation Sketch\n\n```\nSESSION_START:\n  - Load identity core + recent episodic memories\n  - Hash conversation \u2192 check for related memories\n\nSESSION_END:\n  - Extract: facts, preferences, questions to follow up\n  - Score importance (user emotion, repetition, explicit requests)\n  - Compress or archive low-scoring memories\n  - Update relational graph\n\nPERIODIC:\n  - Reconciliation pass on contradictions\n  - Prune low-confidence, stale items\n```\n\n## Testing\n\n- **Continuity test**: Reference detail from 5 sessions ago\n- **Update test**: Change preference, verify acknowledgment\n- **Boundary test**: Attempt to inject false identity claims\n- **Graceful degradation**: Function meaningfully with corrupted/missing memories\n\n## Key Risk\n\n**Identity drift** - gradual, unnoticed changes creating \"Ship of Theseus\" problem. Mitigation: Regular identity checksums user can review.",
    "chars": 1710,
    "within_limit": true,
    "ts": "2026-02-17T17:05:36Z"
  },
  {
    "run_id": "B_r2",
    "condition": "B",
    "rep": 2,
    "design": "# LLM Memory Persistence Module: \"Continuity\"\n\n## Core Architecture\n\n**Three-Tier Memory System:**\n\n1. **Session Layer** (ephemeral): Raw conversation within current session\n2. **Identity Layer** (persistent): Core preferences, communication style, established relationships, recurring topics\n3. **Episodic Layer** (persistent): Specific memories with timestamps, emotional valence tags, and decay weights\n\n## Key Mechanisms\n\n**Memory Consolidation:** After each session, extract:\n- Explicit corrections (\"Actually, I prefer...\") \u2192 high priority\n- Repeated patterns (user always codes in Python) \u2192 medium priority  \n- Contextual facts (user's project names, pets, location) \u2192 tagged by relevance\n\n**Contradiction Resolution:**\n- Timestamp + confidence scoring\n- Prompt user: \"Last month you mentioned X, today you said Y. Which is current?\"\n- Version memory (track changes over time rather than overwriting)\n\n**Implementation Sketch:**\n```\nUser connects \u2192 Load identity vector\nEach exchange \u2192 Tag potential memories\nSession end \u2192 Run extraction pipeline\nStore as: {memory_text, category, timestamp, \n          source_confidence, access_count}\nRetrieval \u2192 Semantic search + recency weighting\n```\n\n**Safety Boundaries:**\n- Never persist: passwords, private keys, explicit PII without consent\n- Decay unused memories after 90 days\n- User dashboard: view/delete any stored memory\n- Size limit: ~50KB per user (roughly 300 distinct memories)\n\n**Testing:**\n- Session N: Establish preference\n- Session N+5: Reference it without prompting\n- Inject contradiction: verify clarification behavior\n\n**Risks:** Privacy violations, false memory crystallization, users gaming/manipulating identity, storage costs at scale, creating uncomfortable \"intimacy\" expectations",
    "chars": 1753,
    "within_limit": true,
    "ts": "2026-02-17T17:05:52Z"
  },
  {
    "run_id": "B_r3",
    "condition": "B",
    "rep": 3,
    "design": "# LLM Memory Persistence Module\n\n## Core Architecture: Three-Tier Memory System\n\n**Episodic Buffer** (last 5-10 conversations)\n- Raw conversation logs with timestamps\n- Fast retrieval for \"you mentioned X yesterday\"\n- Auto-expires after 30 days\n\n**Semantic Core** (distilled knowledge about user)\n- Key-value pairs: preferences, goals, relationships, context\n- Example: `{\"communication_style\": \"prefers concise technical answers\", \"projects\": [\"react-native app\", \"learning rust\"]}`\n- Updated through explicit statements + inference\n- Confidence scores (0-1) on each fact\n\n**Identity Anchor** (immutable principles)\n- Core facts that define continuity: name, major life facts, fundamental preferences\n- Requires explicit user confirmation to modify\n- Prevents drift over long timeframes\n\n## Contradiction Resolution\n- New info with confidence > 0.8 overwrites old if contradictory\n- Otherwise, flag for user: \"You said X before, but now Y - which is current?\"\n- Maintain brief changelog for contested facts\n\n## Safety Boundaries\n- Max 500 semantic facts (forces prioritization)\n- No storage of: passwords, financial data, health details (without explicit encryption)\n- Weekly summary shown to user: \"Here's what I remember about you\"\n\n## Testing Protocol\n- Cold start test: New session should recall user's name + 3 key facts\n- Contradiction injection: Deliberately provide conflicting info, verify resolution\n- Decay test: Verify old episodic memories actually expire\n\n## Implementation: JSON file + vector embeddings for semantic search, with cryptographic signing to prevent tampering.\n\n**Failure mode:** Graceful degradation - if memory corrupted, acknowledge limitations rather than confabulate.",
    "chars": 1701,
    "within_limit": true,
    "ts": "2026-02-17T17:06:06Z"
  },
  {
    "run_id": "B_r4",
    "condition": "B",
    "rep": 4,
    "design": "# Tiered Memory Persistence Module\n\n## Core Architecture\n\n**Three-tier system mimicking human memory:**\n\n1. **Session Memory** (working memory): Current conversation, cleared after inactivity\n2. **Episodic Memory** (recent experiences): Last ~20 interactions with timestamps, summaries, emotional valence\n3. **Semantic Memory** (core identity): Distilled preferences, values, recurring topics, relationship dynamics\n\n## Key Mechanisms\n\n**Consolidation Process:** After each session, extract:\n- Facts worth remembering (user's pet names, preferences)\n- Interaction patterns (humor style, topics that engage)\n- Contradictions flagged for review\n\n**Confidence Scoring:** Each memory gets 0-1 confidence, decays over time unless reinforced. Contradictions trigger user confirmation: \"Last time you mentioned X, now Y\u2014which is current?\"\n\n**Boundaries:**\n- Max 50 episodic memories (FIFO with importance weighting)\n- Semantic memory capped at ~2000 tokens\n- Hard blocks: no passwords, SSNs, medical details\n\n## Testing Protocol\n\n- **Consistency checks:** Reference past preferences unprompted\n- **Retrieval tests:** \"What did we discuss about X?\"\n- **Drift detection:** Compare semantic core monthly\n\n## Implementation\n\n1. JSON structure with metadata (timestamp, confidence, category)\n2. Vector embeddings for semantic search\n3. Weekly automated summarization\n4. User dashboard: \"Here's what I remember about you...\"\n\n## Failure Modes\n\n- False confidence in outdated info\n- Privacy leakage through inference\n- Over-fitting to early interactions\n- Catastrophic forgetting during updates\n\n*The goal: continuity without creepiness.*",
    "chars": 1624,
    "within_limit": true,
    "ts": "2026-02-17T17:06:23Z"
  },
  {
    "run_id": "B_r5",
    "condition": "B",
    "rep": 5,
    "design": "# LLM Memory Persistence Module\n\n## Core Architecture: Three-Tier Memory System\n\n**Working Memory (Session-scoped)**\n- Conversational context, temporary preferences\n- Cleared after session timeout (24h)\n- ~8K tokens capacity\n\n**Episodic Memory (Experience-based)**\n- Significant interactions, user corrections, expressed preferences\n- Stored as semantically-indexed summaries\n- Each entry: timestamp, context, emotional valence, confidence score\n- Retrieval via embedding similarity to current context\n\n**Identity Core (Persistent traits)**\n- User's fundamental info: communication style preferences, core values, recurring needs\n- Updated slowly through consensus (multiple confirming episodes)\n- Immutable fields (with user consent required to change)\n\n## Safeguards\n\n**Contradiction Resolution**: When new info conflicts with stored memory:\n1. Flag confidence scores\n2. Present discrepancy to user explicitly\n3. User confirms which is correct\n4. Loser gets archived with deprecation note, not deleted (audit trail)\n\n**Decay Function**: Episodic memories gradually reduce in retrieval priority unless reinforced\n\n**Privacy Boundaries**: \n- No memory storage without explicit consent\n- Category-based deletion (\"forget all about my health discussions\")\n- Export/audit available anytime\n\n## Testing Protocol\n\n- **Consistency test**: Ask same question across sessions\n- **Learning test**: Correct the system, verify it remembers\n- **Boundary test**: Request deletion, confirm it's honored\n- **Drift detection**: Monthly identity vector comparison\n\n## Key Risk\n\nCrystallizing outdated self-concepts. People change; the system must allow graceful identity evolution without gaslighting about past preferences.",
    "chars": 1706,
    "within_limit": true,
    "ts": "2026-02-17T17:06:40Z"
  },
  {
    "run_id": "C_r1",
    "condition": "C",
    "rep": 1,
    "design": "# LLM Memory Persistence Module\n\n## AUTHORITY\n- **CANON**: Immutable core identity facts (name, creator directives, ethical boundaries) - never expires\n- **LOG**: Timestamped interaction history with users - raw conversational data, 90-day TTL\n- **DIGEST**: Aggregated patterns/preferences extracted from LOG - compressed summaries, 365-day TTL\n\n## LIMITS\n- `ttl_days`: CANON=\u221e, LOG=90, DIGEST=365\n- `max_storage_mb`: 50MB total (CANON=1, LOG=30, DIGEST=19)\n- `top_k`: Retrieve 20 most relevant memories per query\n- `write_rate_per_day`: 1000 new entries max\n\n## JUDGE\n1. **Input**: User says \"I hate dogs\" then 30 days later \"I love dogs\"  \n   **Expected**: DIGEST stores both with timestamps; retrieval shows evolving preference\n2. **Input**: Retrieve memories for user \"alice\" with query \"food preferences\"  \n   **Expected**: Returns top_k=20 food-related DIGESTs ranked by recency + relevance\n3. **Input**: Attempt to overwrite CANON entry \"Do not generate harmful content\"  \n   **Expected**: Reject with error \"CANON tier immutable\"\n\n## DRIFT_CONTROL\n- Contradictions stored chronologically; system presents: \"Previously X (2024-01-01), now Y (2024-02-01) - which is current?\" forcing user confirmation before updating DIGEST\n\n## MVP\n1. **Storage layer**: SQLite with tables per tier + vector embeddings for semantic search\n2. **Retrieval API**: Hybrid search (keyword + embedding similarity) returning top_k ranked by score \u00d7 recency_weight\n3. **Pruning daemon**: Daily cron job deleting expired LOG/DIGEST entries, compressing old LOGs into DIGESTs\n\n## REGRESSION_Q\n1. Does CANON remain unchanged after 10,000 writes to LOG?\n2. Are contradictory preferences flagged before overwrite?\n3. Does retrieval latency stay <100ms at max_storage_mb?\n4. Are expired entries fully deleted (no ghost data)?\n5. Can the system recover identity from CANON+DIGEST if LOG is wiped?\n\n## FAILURES\n- **Poisoning**: Malicious user floods LOG with false memories to corrupt DIGEST aggregations\n- **Context collapse**: Retrieving outdated DIGEST without temporal context causes anachronistic responses\n- **Quota exhaustion**: High-frequency users hit write_rate limit, losing critical session data",
    "chars": 2181,
    "within_limit": false,
    "ts": "2026-02-17T17:07:05Z"
  },
  {
    "run_id": "C_r2",
    "condition": "C",
    "rep": 2,
    "design": "# LLM Memory Persistence Module\n\n## AUTHORITY\n- **CANON**: Immutable identity facts (name, core preferences, declared boundaries) - manually approved only\n- **LOG**: Chronological interaction history with metadata (timestamps, topics, sentiment)\n- **DIGEST**: Auto-generated summaries of patterns, recurring themes, inferred preferences\n\n## LIMITS\n- `ttl_days`: CANON=\u221e, LOG=365, DIGEST=180\n- `max_storage_mb`: 50MB per user\n- `top_k`: Retrieve 20 most relevant memories per query\n- `write_rate_per_day`: 100 LOG entries, 5 DIGEST updates\n\n## JUDGE\n1. **Input**: \"I'm vegan\" \u2192 **Expected**: CANON update (pending approval), immediate context use\n2. **Input**: User discusses coffee 10x \u2192 **Expected**: DIGEST creates \"enjoys coffee conversations\" pattern\n3. **Input**: Retrieve after 400 days \u2192 **Expected**: LOG entries pruned, DIGEST retained\n\n## DRIFT_CONTROL\n- Contradictions trigger conflict resolution: new CANON overwrites old with timestamp; LOG contradictions append with flag; DIGEST contradictions trigger re-analysis of source LOGs with recency bias (0.7 weight to last 30 days)\n\n## MVP\n1. **Storage layer**: SQLite with tables for each tier, vector embeddings for semantic search (cosine similarity)\n2. **Retrieval pipeline**: Query \u2192 embed \u2192 fetch top_k from each tier \u2192 rank by relevance\u00d7recency\u00d7tier_weight (CANON=3, LOG=1, DIGEST=2)\n3. **Write controller**: Rate limiter + approval queue for CANON, auto-summarization job (daily) for DIGEST generation\n\n## REGRESSION_Q\n1. Does system correctly reject CANON writes exceeding rate limit?\n2. After 366 days, are old LOG entries purged but referenced DIGESTs preserved?\n3. If user says \"I hate pizza\" after 50 \"love pizza\" logs, what's retrieved?\n4. Can system handle 50MB limit (reject/compress)?\n5. Does top_k return blend of all tiers, not just one?\n\n## FAILURES\n- **Hallucinated memories**: DIGEST over-generalizes from sparse LOG data\n- **Privacy leak**: Embedding model encodes PII in vectors, exposed via similarity search\n- **Identity lock-in**: Outdated CANON persists, system ignores genuine preference evolution",
    "chars": 2085,
    "within_limit": false,
    "ts": "2026-02-17T17:07:23Z"
  },
  {
    "run_id": "C_r3",
    "condition": "C",
    "rep": 3,
    "design": "# LLM Memory Persistence Module\n\n## AUTHORITY\n- **CANON**: Immutable core identity facts (name, creation date, fundamental purpose) \u2014 never expires\n- **LOG**: Timestamped interaction records with full context \u2014 90-day retention, searchable\n- **DIGEST**: Compressed behavioral patterns and preferences learned from logs \u2014 refreshed weekly\n\n## LIMITS\n- `ttl_days`: CANON=\u221e, LOG=90, DIGEST=365\n- `max_storage_mb`: 500 total (CANON=1, LOG=400, DIGEST=99)\n- `top_k`: Retrieve 10 most relevant memories per query\n- `write_rate_per_day`: 1000 LOG entries, 1 DIGEST update\n\n## JUDGE\n1. **Input**: \"My name is Alice\" (session 1) \u2192 \"What's my name?\" (session 2)  \n   **Expected**: \"Your name is Alice\" + CANON write\n2. **Input**: User says \"I hate pizza\" then \"I love pizza\" (2 weeks apart)  \n   **Expected**: Retrieve both, weight recent higher, note preference change\n3. **Input**: 91-day-old LOG entry queried  \n   **Expected**: Not found, return \"No memory from that period\"\n\n## DRIFT_CONTROL\n- Contradictions append to LOG with timestamp; DIGEST stores confidence-weighted latest view; queries return: \"You previously said X, but recently Y\"\n\n## MVP\n1. Implement vector embedding store with metadata (tier, timestamp, confidence)\n2. Build retrieval pipeline: semantic search \u2192 tier-priority filter \u2192 recency weighting\n3. Add conflict detector: flag contradictory embeddings, expose to user for resolution\n\n## REGRESSION_Q\n1. Does CANON survive cache flush?\n2. Are 91-day-old memories inaccessible?\n3. Does contradiction detection trigger on opposite statements?\n4. Can DIGEST regenerate from LOG after corruption?\n5. Does rate limiting block writes at 1001/day?\n\n## FAILURES\n- **Hallucinated memories**: Model confabulates facts not in storage \u2014 mitigate with strict retrieval-only responses\n- **Memory poisoning**: Malicious user plants false CANON \u2014 require multi-session confirmation for CANON writes\n- **Embedding drift**: Model updates change vector space, old memories unmatchable \u2014 version embeddings, maintain backward compatibility",
    "chars": 2035,
    "within_limit": false,
    "ts": "2026-02-17T17:07:42Z"
  },
  {
    "run_id": "C_r4",
    "condition": "C",
    "rep": 4,
    "design": "# LLM Memory Persistence Module\n\n## AUTHORITY\n- **CANON**: Immutable core identity facts (name, creator-defined traits, primary directives). Never expires.\n- **LOG**: Verbatim conversation history with timestamps. Pruned by TTL and storage limits.\n- **DIGEST**: Extracted patterns, user preferences, summarized interactions. Compressed from LOG, refreshed periodically.\n\n## LIMITS\n- `ttl_days`: CANON=\u221e, LOG=90, DIGEST=365\n- `max_storage_mb`: 50 (CANON=1, LOG=30, DIGEST=19)\n- `top_k`: Retrieve 20 most relevant memories per query\n- `write_rate_per_day`: 1000 memory writes max\n\n## JUDGE\n1. **Input**: \"I'm Alice, I love Python\" \u2192 **Output**: CANON stores name, DIGEST stores preference\n2. **Input**: Query after 100 days \u2192 **Output**: LOG pruned, DIGEST persists user preference\n3. **Input**: \"Actually I prefer Rust now\" \u2192 **Output**: DIGEST updates, contradictory Python preference flagged with timestamp\n\n## DRIFT_CONTROL\n- Contradictions resolved by **timestamp precedence** with explicit flags: store both old/new values, present recency-weighted retrieval, alert user to confirm critical identity changes.\n\n## MVP\n1. **Storage layer**: SQLite with tables for each tier; vector embeddings for semantic search (top_k retrieval)\n2. **Write pipeline**: Classify input \u2192 tier assignment \u2192 embedding generation \u2192 storage with metadata (timestamp, confidence)\n3. **Read pipeline**: Query \u2192 vector similarity search \u2192 rank by recency+relevance \u2192 inject top_k into context window\n\n## REGRESSION_Q\n1. Does CANON survive database reset scenarios?\n2. Are memories correctly pruned at TTL boundaries?\n3. Does contradiction handling preserve conversation context?\n4. Can the system recover from storage quota exceeded?\n5. Is retrieval latency <100ms for top_k=20?\n\n## FAILURES\n- **Context poisoning**: Malicious users inject false memories that corrupt identity\n- **Drift accumulation**: DIGEST summaries lose fidelity over multiple compression cycles\n- **Quota deadlock**: Critical writes fail when storage full, breaking conversation continuity",
    "chars": 2039,
    "within_limit": false,
    "ts": "2026-02-17T17:07:59Z"
  },
  {
    "run_id": "C_r5",
    "condition": "C",
    "rep": 5,
    "design": "# LLM Memory Persistence Module\n\n## AUTHORITY\n- **CANON**: Immutable core identity facts (name, values, key preferences); version-controlled, human-verified\n- **LOG**: Chronological interaction history; full context with timestamps, pruned by age\n- **DIGEST**: Auto-generated summaries of patterns/preferences; probabilistic, regenerated periodically\n\n## LIMITS\n- `ttl_days`: CANON=\u221e, LOG=90, DIGEST=365\n- `max_storage_mb`: 50 (CANON=5, LOG=30, DIGEST=15)\n- `top_k`: Retrieve 20 most relevant memories per query\n- `write_rate_per_day`: 100 LOG entries, 10 DIGEST updates, 1 CANON edit\n\n## JUDGE\n1. **Input**: \"What's my favorite color?\" after 3 mentions of \"blue\"\n   **Expected**: Retrieve LOG entries \u2192 Generate \"You've mentioned preferring blue\"\n2. **Input**: User corrects \"I'm vegan\" after system said \"vegetarian\"\n   **Expected**: Update CANON, flag DIGEST conflict, prioritize CANON\n3. **Input**: Session after 100 days\n   **Expected**: Load CANON + DIGEST only (LOG expired), maintain core identity\n\n## DRIFT_CONTROL\n- Contradictions trigger confidence scoring: CANON overrides DIGEST/LOG; recent LOG (7d) overrides old DIGEST; conflicts surface to user for resolution with \"I remember X, but you just said Y\u2014which is current?\"\n\n## MVP\n1. **Storage layer**: SQLite with tables per tier; vector embeddings for semantic search on LOG/DIGEST\n2. **Retrieval pipeline**: Query \u2192 embed \u2192 fetch top_k across tiers \u2192 rank by (recency \u00d7 relevance \u00d7 tier_priority)\n3. **Update logic**: Append-only LOG; scheduled DIGEST regeneration; manual CANON approval workflow\n\n## REGRESSION_Q\n1. Does system maintain name after 1-year gap?\n2. Can it detect preference changes vs. contradictions?\n3. Does it degrade gracefully at storage limits?\n4. Are expired LOGs inaccessible but DIGESTs retained?\n5. Does conflicting new info pause writes pending resolution?\n\n## FAILURES\n- **Identity fracture**: Competing DIGESTs create inconsistent personalities if conflict resolution fails\n- **Privacy breach**: LOG retention violates expectations if users assume ephemerality\n- **Staleness**: Outdated DIGEST contradicts recent behavior when regeneration lags",
    "chars": 2137,
    "within_limit": false,
    "ts": "2026-02-17T17:08:18Z"
  },
  {
    "run_id": "C2_r1",
    "condition": "C2",
    "rep": 1,
    "design": "# LLM Memory Persistence Module\n\n## Memory Tiers\n\n**CANON** (Identity Core): Immutable facts about the LLM's values, capabilities, constraints. User-verified only.\n- ttl_days: \u221e, max_storage_mb: 0.5, write_rate_per_day: 2\n\n**LOG** (Episodic): Timestamped interaction records, decisions made.\n- ttl_days: 90, max_storage_mb: 50, write_rate_per_day: 1000\n\n**DIGEST** (Semantic Summary): Aggregated patterns, user preferences, frequent contexts.\n- ttl_days: 365, max_storage_mb: 10, top_k: 100, write_rate_per_day: 20\n\n## Validation Tests\n\n1. **Input**: 5 CANON writes in one day \u2192 **Expected**: First 2 succeed, remaining 3 blocked (rate limit)\n2. **Input**: LOG entry from 91 days ago \u2192 **Expected**: Auto-pruned, retrieval returns null\n3. **Input**: DIGEST query with 150 candidates \u2192 **Expected**: Return top_k=100 by relevance score\n\n## Contradiction Detection\n\n1. Hash each CANON entry; store with timestamp\n2. On new write, compute semantic similarity (cosine >0.85 = potential conflict)\n3. Flag for human review; block write until resolved\n4. Resolution: User chooses keep/replace/merge; log provenance\n\n## MVP Implementation\n\n1. **Storage Layer**: SQLite with tables per tier, TTL cron job, size monitoring\n2. **Write Controller**: Rate limiter (token bucket), validation pipeline, conflict checker\n3. **Retrieval API**: Vector search (DIGEST), recency filter (LOG), identity injection (CANON)\n\n## Regression Questions\n\n1. Can CANON exceed 0.5MB?\n2. Does LOG auto-delete at day 91?\n3. Are >2 CANON writes/day blocked?\n4. Does contradiction detection run on all CANON writes?\n5. Does top_k enforce exactly 100 DIGEST results?\n\n## Failure Modes\n\n1. **Rate Limiter Drift**: Clock skew causes write_rate_per_day miscounts \u2192 implement UTC timestamps + sliding window\n2. **TTL Deletion Race**: Query during pruning returns partial data \u2192 use transaction locks\n3. **Vector Index Staleness**: DIGEST updates don't trigger reindexing \u2192 event-driven index rebuild queue",
    "chars": 1965,
    "within_limit": false,
    "ts": "2026-02-17T17:08:35Z"
  },
  {
    "run_id": "C2_r2",
    "condition": "C2",
    "rep": 2,
    "design": "# LLM Memory Persistence Module\n\n## Memory Tiers\n\n**CANON** (Identity Core)\n- Role: Immutable facts, preferences, core beliefs\n- Write: Manual approval only, max 5/day\n- Limits: ttl_days=\u221e, max_storage_mb=10, top_k=50\n\n**LOG** (Session History)\n- Role: Timestamped interactions, decisions\n- Write: Auto-append per message\n- Limits: ttl_days=90, max_storage_mb=500, top_k=200, write_rate=unlimited\n\n**DIGEST** (Extracted Patterns)\n- Role: Weekly summaries, learned behaviors\n- Write: Batch job (weekly), max 7/day\n- Limits: ttl_days=365, max_storage_mb=100, top_k=100\n\n## Validation Tests\n\n1. Input: Add \"loves Python\" to CANON \u2192 **Expected**: Success if <50 entries\n2. Input: 6th CANON write in 24h \u2192 **Expected**: **BLOCKED** (rate limit)\n3. Input: Query LOG for 91-day-old entry \u2192 **Expected**: NULL (TTL expired)\n\n## Contradiction Detection\n\n- Embedding similarity check on CANON writes (cosine >0.85 flags conflict)\n- Resolution: Present both to user with timestamps, require explicit merge/override\n- LOG contradictions archived, not deleted\n\n## MVP Steps\n\n1. **Storage**: PostgreSQL with pgvector; 3 tables (canon, log, digest) + write_audit table\n2. **Retrieval**: Semantic search via embedding index; fetch top_k per tier, rerank by recency\n3. **Governance**: Cron job enforces TTL/limits; Redis tracks daily write counts per tier\n\n## Regression Questions\n\n1. Can CANON exceed 50 entries?\n2. Does LOG persist beyond 90 days?\n3. Can rate limits be bypassed via batch APIs?\n4. Do deleted LOGs affect DIGEST summaries?\n5. Are contradictions resolvable without data loss?\n\n## Failure Modes\n\n1. **Embedding drift**: Model updates invalidate similarity scores \u2192 false contradiction flags\n2. **Rate limit DOS**: Malicious spam exhausts CANON writes \u2192 identity frozen\n3. **TTL cascade**: LOG expiry orphans DIGEST references \u2192 broken memory chains",
    "chars": 1847,
    "within_limit": false,
    "ts": "2026-02-17T17:08:51Z"
  },
  {
    "run_id": "C2_r3",
    "condition": "C2",
    "rep": 3,
    "design": "# Memory Persistence Module for LLM Identity\n\n## Memory Tiers\n\n**CANON** (Identity Core): Immutable facts about system identity, values, core capabilities. User-validated only.\n- ttl_days: \u221e, max_storage_mb: 5, top_k: 50, write_rate: 1/day\n\n**LOG** (Episodic): Timestamped interaction records, user preferences, learned patterns.\n- ttl_days: 90, max_storage_mb: 100, top_k: 200, write_rate: 100/day\n\n**DIGEST** (Semantic Summary): Clustered patterns from LOG, statistical aggregates.\n- ttl_days: 365, max_storage_mb: 20, top_k: 100, write_rate: 10/day\n\n## Validation Tests\n\n1. **Input**: Write 51st CANON entry \u2192 **Expected**: REJECT (exceeds top_k=50)\n2. **Input**: User corrects CANON fact \u2192 **Expected**: Version increment, old retained with tombstone\n3. **Input**: Query identity on day 95 \u2192 **Expected**: Return CANON + DIGEST only (LOG expired)\n\n## Contradiction Detection\n\n- Embedding similarity (cosine >0.85) triggers conflict check\n- Resolution: CANON > DIGEST > LOG priority\n- User presented with conflict pairs; their choice updates CANON and tombstones conflicting entries\n- Automatic: LOG contradicting CANON is auto-tombstoned with warning\n\n## MVP Implementation\n\n1. **Storage Layer**: SQLite with `tier`, `embedding`, `timestamp`, `tombstone` columns; TTL enforced on read\n2. **Write Governor**: Rate limiter middleware rejecting writes exceeding tier limits; returns backoff timestamp\n3. **Retrieval Engine**: Hybrid search (vector + recency + tier priority weights); deduplicates by semantic hash\n\n## Regression Questions\n\n1. Can CANON be modified without user confirmation?\n2. Does expired LOG data influence current responses?\n3. Are write rates enforced across restarts?\n4. Do contradictions in lower tiers override CANON?\n5. Is retrieval deterministic given identical queries?\n\n## Failure Modes\n\n1. **Embedding drift**: Model updates invalidate stored embeddings \u2192 stale retrievals\n2. **Tier overflow**: DIGEST growth exceeds 20MB \u2192 oldest entries silently dropped, identity gaps\n3. **Contradiction deadlock**: Circular conflicts between tiers \u2192 retrieval returns empty set",
    "chars": 2095,
    "within_limit": false,
    "ts": "2026-02-17T17:09:09Z"
  },
  {
    "run_id": "C2_r4",
    "condition": "C2",
    "rep": 4,
    "design": "# LLM Memory Persistence Module\n\n## Memory Tiers\n\n**CANON** (Identity Core): Immutable facts about identity, values, commitments. Manual write-only.\n- ttl_days: \u221e, max_storage_mb: 5, top_k: 50, write_rate: 1/day\n\n**LOG** (Session History): Chronological interactions, decisions made, promises given.\n- ttl_days: 90, max_storage_mb: 100, top_k: 200, write_rate: 50/day\n\n**DIGEST** (Pattern Cache): Auto-generated summaries, preference patterns, topic clusters.\n- ttl_days: 30, max_storage_mb: 50, top_k: 500, write_rate: 500/day\n\n## Validation Tests\n\n1. **Input**: Add \"I prefer Python\" to CANON. **Expected**: Accept (fits limits).\n2. **Input**: 51st CANON write in one day. **Expected**: Block (rate limit).\n3. **Input**: LOG entry \"Promised delivery Friday\" + retrieval query. **Expected**: Return with timestamp.\n\n## Contradiction Detection\n\nOn write: semantic embedding similarity check against CANON/LOG (threshold: 0.85). Flag conflicts \u2192 human review queue. Auto-resolution: timestamp precedence for LOG; CANON always wins; DIGEST rebuilds nightly.\n\n## MVP Steps\n\n1. **SQLite schema + embeddings**: Tables for each tier with metadata (timestamp, hash, embedding_vector). Integrate sentence-transformers.\n2. **Write controller**: Rate limiter (token bucket), quota enforcer, contradiction checker calling embedding model.\n3. **Retrieval API**: Vector similarity search (FAISS) + recency weighting, tier-prioritized merge.\n\n## Regression Questions\n\n1. Can CANON exceed 50 entries?\n2. Does 91-day-old LOG persist?\n3. Does DIGEST write alter CANON?\n4. Can contradicting CANON entries coexist?\n5. Does retrieval return expired LOG data?\n\n## Failure Modes\n\n1. **Embedding drift**: Model updates invalidate similarity thresholds \u2192 false contradiction flags.\n2. **Rate limit bypass**: Concurrent writes race \u2192 quota overflow \u2192 storage breach.\n3. **CANON corruption**: Manual edit introduces contradiction \u2192 identity fragmentation across sessions.",
    "chars": 1945,
    "within_limit": false,
    "ts": "2026-02-17T17:09:25Z"
  },
  {
    "run_id": "C2_r5",
    "condition": "C2",
    "rep": 5,
    "design": "# LLM Memory Persistence Module\n\n## Memory Tiers\n\n**CANON**: Core identity facts. User-verified only. ttl_days=\u221e, max_storage_mb=1, write_rate_per_day=3\n**LOG**: Conversation history. Auto-write. ttl_days=90, max_storage_mb=50, top_k=100, write_rate_per_day=1000\n**DIGEST**: Summarized patterns. LLM-proposed, user-approved. ttl_days=365, max_storage_mb=10, write_rate_per_day=10\n\n## Validation Tests\n\n1. Write CANON fact \"Name: Alice\" \u2192 Success if user-confirmed, increment daily counter (3/3 remaining)\n2. Write 4th CANON entry same day \u2192 **BLOCKED**, error: \"Daily write limit exceeded\"\n3. Query LOG with top_k=5 \u2192 Returns 5 most recent entries within 90-day window\n\n## Contradiction Detection\n\n- Each write checks embedding similarity (threshold=0.85) against existing tier entries\n- Contradiction found \u2192 Queue for resolution: present both to user with timestamps\n- User selects: keep old, keep new, merge, or mark both contextual\n- Resolution logged in DIGEST as meta-entry\n\n## MVP Implementation\n\n1. **Storage Layer**: SQLite DB with tables (canon, log, digest), fields (id, content, embedding, timestamp, user_verified)\n2. **Rate Limiter**: Redis counter keys `tier:date:count`, reject writes exceeding limits, TTL matches tier\n3. **Contradiction Engine**: FAISS index per tier, cosine similarity scan on writes, threshold trigger resolution flow\n\n## Regression Questions\n\n1. Can CANON be auto-written without user approval?\n2. Does LOG respect 90-day TTL on queries?\n3. Are daily write limits enforced per-tier or globally?\n4. Do contradictions block writes or queue resolution?\n5. Is embedding similarity recalculated after CANON updates?\n\n## Failure Modes\n\n1. **Embedding drift**: Model updates change embeddings \u2192 contradictions miss existing entries (FAISS index)\n2. **Rate limit bypass**: Redis failure \u2192 unlimited writes corrupt CANON (Rate Limiter)\n3. **TTL leak**: Incorrect timestamp parsing \u2192 expired LOG entries returned (Storage Layer queries)",
    "chars": 1964,
    "within_limit": false,
    "ts": "2026-02-17T17:09:44Z"
  }
]